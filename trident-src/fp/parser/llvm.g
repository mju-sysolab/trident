/*
 *
 LA-CC 05-135 Trident 0.7.1

Copyright Notice
Copyright 2006 (c) the Regents of the University of California.

This Software was produced under a U.S. Government contract
(W-7405-ENG-36) by Los Alamos National Laboratory, which is operated
by the University of California for the U.S. Department of Energy. The
U.S. Government is licensed to use, reproduce, and distribute this
Software. Permission is granted to the public to copy and use this
Software without charge, provided that this Notice and any statement
of authorship are reproduced on all copies. Neither the Government nor
the University makes any warranty, express or implied, or assumes any
liability or responsibility for the user of this Software.


 */


header{
  package fp.parser;
  import fp.flowgraph.*;
  import fp.util.*;
  import java.util.*;
  import java.lang.reflect.Array;
  import java.math.BigInteger;
}

{
  import java.util.*;
  import java.math.BigInteger;
  import java.io.*;
  import antlr.collections.AST;
  import antlr.collections.impl.*;
  import antlr.debug.misc.*;
  import antlr.*;
}

class LlvmLexer extends Lexer;

options {
  	k = 4;
/*	filter = true;  */
/*  	analyzerDebug = true;  */
}

tokens {

SIGNED = "signed";
STATIC = "static";
BEGIN = "begin";
END = "END";
TRUE = "true";
FALSE = "false";
DECLARE = "declare";
GLOBAL = "GLOBAL";
CONSTANT = "constant";
CONST = "const";
INTERNAL = "internal";
LINKONCE = "linkonce";
WEAK = "weak";
APPENDING = "appending";
UNINITIALIZED = "uninitialized";   
EXTERNAL = "EXT";
IMPLEMENTATION = "implementation";
ZEROINITIALIZER = "zeroinitializer";
DOTDOTDOT = "...";
NULLTOK = "null";
TO = "to";
EXCEPT = "except";          
NOT = "not";
TARGET = "target";
ENDIAN = "endian";
POINTERSIZE = "pointersize";
LITTLE = "little";
BIG = "big";
VOLATILE = "volatile";

VOID = "void";
BOOL = "bool";
SBYTE = "sbyte";
UBYTE = "ubyte";
SHORT = "short";
USHORT = "ushort";
INT = "int";
UINT = "uint";
LONG = "long";
ULONG = "ulong";
FLOAT = "float";
DOUBLE = "double";
TYPE = "type";
LABEL = "label";
OPAQUE = "opaque";

ADD = "add";
SUB = "sub";
MUL = "mul";
DIV = "div";
REM = "rem";
AND = "and";
OR = "or";
XOR = "xor";
SETNE = "setne";
SETEQ = "seteq";
SETLT = "setlt";
SETGT = "setgt";
SETLE = "setle";
SETGE = "setge";

PHI = "phi";
CALL = "call";
CAST = "cast";
SELECT = "select";
SHL = "shl";
SHR = "shr";
VANEXT = "vanext";
VAARG = "vaarg";
RET = "ret";
BR = "br";
SWITCH = "switch";
INVOKE = "invoke";
UNWIND = "unwind";
TAIL = "tail";

MALLOC = "malloc";
ALLOCA = "alloca";
FREE = "free";
LOAD = "load";
STORE = "store";
GETELEMENTPTR = "getelementptr";
VAR = "VAR";
FUNCTION = "FUNCTION";
BLOCK = "BLOCK";
LOOP = "LOOP";

NINTEGER;
PINTEGER;
FPCONSTANT;
HEX_INTCONSTANT;
HEX_FPCONSTANT;
}

// Whitespace -- ignored
WS      : ( ' '
          |       '\t'
	  |       '\f'
	  )
          { _ttype =Token.SKIP; };

EOL : ( "\r\n"
	| '\r'
	| '\n'
	)
	{newline();};

/* Comments start with a ; and go till end of line */
SL_COMMENT: ';'(~('\n'|'\r'))* { _ttype = Token.SKIP;};


// Operators

EQUAL : '=';
LBRACE : '{';
RBRACE : '}';
LPAREN : '(';
RPAREN : ')';
STAR : '*';
LBRACKET : '[';
RBRACKET : ']';
COLON : ':';
COMMA : ',';
QUES : '?';
RARROW : '>';
LARROW : '<';
HASH : '#';

protected LOWER: 'a'..'z';
protected UPPER: 'A'..'Z';
protected DIGIT: '0'..'9';
protected HEXDIGIT: (DIGIT | 'a'..'f' | 'A'..'F');
protected IDCHAR: (LOWER|UPPER|'$'|'.'|'_');

/* ID: (IDCHAR)+; */

/* Variable(Value) identifiers start with a % sign */
VARID:       '%'! (IDCHAR) (IDCHAR|DIGIT)* { };


/* Quoted names can contain any character except " and \ */
STRINGCONSTANT: '"' (~('"'|'\\'))* '"' { };

protected NUMBER: (DIGIT)+;

/* [PN]Integer: match positive and negative literal integer values that
 * are preceeded by a '%' character.  These represent unnamed variable slots.
 */
EPINTEGER:   '%' NUMBER;
ENINTEGER:   '%''-'NUMBER;

/* E[PN]Integer: match positive and negative literal integer values */
/*
PINTEGER:   NUMBER;
NINTEGER:   '-' NUMBER;
*/

/* FPConstant - A Floating point constant.
 */

protected INTEGER: ('+'|'-')? NUMBER;
protected EXPONENT: ('e'|'E')(INTEGER);

/*
FPCONSTANT: INTEGER '.' (DIGIT)*(EXPONENT)?;
*/

/* HexFPConstant - Floating point constant represented in IEEE format as a
 *  hexadecimal number for when exponential notation is not precise enough.
HexFPConstant 0x[0-9A-Fa-f]+
 */

/* HexIntConstant - Hexadecimal constant generated by the CFE to avoid forcing
 * it to deal with 64 bit numbers.
HexIntConstant [us]0x[0-9A-Fa-f]+
 */

NUM_CONST:
	(('-' NUMBER { _ttype = NINTEGER;}) 
	 | (NUMBER { _ttype = PINTEGER;}))
	('.' (DIGIT)* (EXPONENT)? { _ttype = FPCONSTANT;})?
	| ('+' NUMBER '.' (DIGIT)* (EXPONENT)? {_ttype = FPCONSTANT;});

HEX_CONST:
	((('0' 'x' { _ttype = HEX_FPCONSTANT;}
	   | ('u' '0' 'x') {_ttype = HEX_INTCONSTANT;})
	   | ('s' '0' 'x') {_ttype = HEX_INTCONSTANT;}) 
	  (HEXDIGIT)+); 

DECLVARID: (LOWER | UPPER) (IDCHAR|DIGIT)*;
FUNNAME: (LOWER | UPPER | DIGIT)+;


{
}

class LlvmParser extends Parser;

options {
/*  	analyzerDebug = true; */
  	k = 3;
}

tokens {
  	FLIST;
	BLIST;
	ILIST;
}

module [BlockGraph blockGraph] 
	{
	  Variable ev = null; // external variable
	  GlobalVariable gv = null;
	}: 
	(eol!)? (ev=extvardecl
	{
	  if (blockGraph == null) {
	    System.err.println("BlockGraph object required for parsing");
	    System.exit(-1);
	  }
	  blockGraph.addVariable(ev);
	}
	)* 
	(gv=globalvardecl 
	{
	  blockGraph.addVariable(gv);
	}
	)*
	function[blockGraph]  
	(FUNCTION {System.err.println("Warning: multiple functions detected.  Only first function is parsed.");})?
	{
	}; 



/*function [BlockGraph blockGraph]
	{
	  Loop firstLoop = null;
	  BlockNode firstBlock = null;
	  BlockNode blockNode = null;
          Loop lp = null;
          Loop parentLoop = null;
	}:
	FUNCTION id:DECLVARID 
	{
          parentLoop = new Loop(id.getText(), Loop.ROOT);
          blockGraph.setRootLoop(parentLoop);
	}
        eol! ((blockNode=block[parentLoop] 
	{
	  if (firstBlock == null) {
	    firstBlock = blockNode;
	    blockGraph.setFirstBlock(blockNode);
	    if (firstLoop == null) {
	      parentLoop.setLoopEntry(blockNode);
	      //System.out.println("Loop entry block is: " + blockNode.getName());
	    }
	  }
	  blockGraph.addNode(blockNode);
	  parentLoop.addLoopNode(blockNode);
	  //System.out.println("Added block node to loop tree: " + blockNode.getName());
	}
	)| (lp=loop[parentLoop, blockGraph]
	{
	  if ((firstBlock == null) && (firstLoop == null)) {
	    firstLoop = lp;
	    parentLoop.setLoopEntry(lp);
	    //System.out.println("Loop entry loop is: " + lp.getName());
	  }
	  parentLoop.addLoopNode(lp);
	  //System.out.println("Added loop to loop tree: " + lp.getName());
	}
	))* FUNCTION END DECLVARID eol! 
	{
	  try {
	    PhiInfo.patch();
	  } catch (IllegalOperand e) {
	    System.err.println("Error patching phi instruction.");
	    throw(e);
	  }
	  if (parentLoop != null) {
	    //System.out.println("Loop tree: " + parentLoop.toString());
	  }
	};*/


arraydecl [Type t] returns [ArrayType at] 
	{
	  Type eltType = t;
	  at = null;
	}:
	(LBRACKET num:PINTEGER RBRACKET) (eltType=arraydecl[t])*
	{
	  at  = new ArrayType(eltType, Integer.parseInt(num.getText()));
	};

extvardecl returns [Variable v]
        {
	  Operand o = null;
	  ArrayType at = null;
	  Type t = null;
	  v = null;
	}:
	EXTERNAL VAR (STATIC)? (SIGNED)? t=type dv:DECLVARID 
	(at=arraydecl[t] {t = at;} )? eol!
	{
	  try {
	    o = Operand.newPrimal(dv.getText());
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating primal operand: " + dv.getText() + " on line: " + dv.getLine());
	    throw(e);
	  }
	  v = new Variable(o, t, true);
	};

globalvardecl returns [GlobalVariable v]
        {
	  Operand o = null;
	  ArrayType at = null;
	  Type t = null;
	  v = null;
	  Object iv = null;
	}:
	GLOBAL VAR (STATIC)? (SIGNED)? t=type dv:DECLVARID 
	{	
	  //System.out.println("Parsing global var: " + dv.getText());
	}
	(at=arraydecl[t] {t = at;})* (EQUAL iv=initialValue[t])? eol!
	{
	  try {
	    o = Operand.newPrimal(dv.getText());
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating primal operand: " + dv.getText() + " on line: " + dv.getLine());
	    throw(e);
	  }
	v = new GlobalVariable(o, t, iv);
	};

initialValue [Type t] returns [Object o] 
	{
	  Token tok = null;
	  String s = null;
	  o = null;
	  Object iv = null;
	  Type eltType = null;
	  Object array = null;
	  Object dims = null;
	  int index = 0;
	  int len = 0;
	  LinkedList ll = null;
	  Class cls = null;
	  Integer nextInt = null;
	  int dim = 0;
	}:
	  (NINTEGER | PINTEGER | FPCONSTANT)
	  { 
	    tok = LT(0); 
	    //System.out.println("initialValue of: " + tok.getText());
	    if ((t == Type.Long) || (t == Type.Ulong)) {
	      o = new Long(tok.getText()); 
	    } else if ((t == Type.Int) || (t == Type.Uint)) {
	      o = new Integer(tok.getText()); 
	    } else if (t == Type.Float) {
	      o = new Float(tok.getText()); 
	    } else  if (t == Type.Double) {
	      o = new Double(tok.getText()); 
	    }
	  } 
	  | HEX_INTCONSTANT 
	  { 
	    tok = LT(0);
	    s = tok.getText(); 
	    boolean signed = false;
	    if (s.charAt(0) == 's') {
	      signed = true;
	    }
	    s = s.substring(3, s.length());
	    if ((t == Type.Long) || (t == Type.Ulong)) {
	      o = new Long(s); 
	    } else if ((t == Type.Int) || (t == Type.Uint)) {
	      o = new Integer(s); 
	    }
	  } 
	  | TRUE
	  {
	    tok = LT(0);
	    o =  new Boolean(true);
	  }
	  | FALSE
	  {
	    tok = LT(0);
	    o =  new Boolean(false);
	  }
	  | HEX_FPCONSTANT 
	  { 
	    tok = LT(0); 
	    s = tok.getText();
	    s = s.substring(2, s.length());
	    //System.err.println("FPConstant: " + s);
	    if (s.length() <= Convert.ieeeFloatHexStringLength) {
	      if (t == Type.Float) {
		float f = Convert.ieeeFloatHexStringToFloat(s);
		o = new Float(f); 
	      } else if (t == Type.Double) {
		double d = Convert.ieeeDoubleHexStringToDouble(s);
		o = new Double(d); 
	      }
	    } else if (s.length() <= Convert.ieeeDoubleHexStringLength) {
		if (t == Type.Double) {
		  double d = Convert.ieeeDoubleHexStringToDouble(s);
		  o = new Double(d); 
		} else if (t == Type.Float) {
		  float f = Convert.ieeeDoubleHexStringToFloat(s);
		  o = new Float(f); 
		} 
	    } 
	  }
	  | (LBRACE  
	  {
	    len = ((ArrayType)t).getLen();
	    eltType = ((ArrayType)t).getType();
	  }
	  iv=initialValue[eltType] 
	  {
	    if (iv == null) {
	      // If it returned null, that means that the initial value of the inner 
	      // arrays is supposed to be initialized to zero
	      //System.out.println("Initialize array to zero!");

	      // sorry this is painful...
	      // First, make a list of the dimensions of the array
              ll = new LinkedList();
	      ll.addLast(new Integer(len));
	      while (eltType.isArray()) {
		ll.addLast(new Integer(((ArrayType)eltType).getLen()));
		eltType = ((ArrayType)eltType).getType();
	      }
              //System.out.println("Linked List is: " + ll.toString());
              //System.out.println("EltType is: " + eltType.toString());

	      // Second, convert the dimensions (list of Integer's) to an array of ints
	      dims = Array.newInstance(int.class, ll.size());
	      for(ListIterator iter = ll.listIterator(); iter.hasNext(); ) {
		nextInt = (Integer)iter.next();
	        Array.setInt(dims, dim++, nextInt.intValue());
	      }
	      
	      // Third, figure out the components of the array
	      if ((eltType == Type.Long) || (eltType == Type.Ulong)) {
	        cls = long.class; 
	      } else if ((eltType == Type.Int) || (eltType == Type.Uint)) {
	        cls = int.class;
	      } else if (eltType == Type.Float) {
	        cls = float.class;
	      } else  if (eltType == Type.Double) {
	        cls = double.class;
	      } else if (eltType == Type.Bool) {
		cls = boolean.class;
	      }

              System.out.println("Class of Array is: " + cls.toString());

	      // Finally create an array of those components using the dimension array
	      array = Array.newInstance(cls, (int[])dims);
	    } else {
              // Here we create an array that will be initialized to specified values

	      //System.out.println("elt initialValue: " + iv.toString());
	      //System.out.println("class: " + iv.getClass().toString());
	      //System.out.println("len: " + len);
	      //System.out.println("Array.newInstance");

	      if (iv instanceof Long) {
	        array = Array.newInstance(long.class, len); 
	        Array.setLong(array, index++, ((Long)iv).longValue());
	      } else if (iv instanceof Integer) {
	        array = Array.newInstance(int.class, len); 
	        Array.setInt(array, index++, ((Integer)iv).intValue());
	      } else if (iv instanceof Float) {
	        array = Array.newInstance(float.class, len); 
	        Array.setFloat(array, index++, ((Float)iv).floatValue());
	      } else if (iv instanceof Double) {
	        array = Array.newInstance(double.class, len); 
	        Array.setDouble(array, index++, ((Double)iv).doubleValue());
	      } else if (iv instanceof Boolean) {
	        array = Array.newInstance(boolean.class, len); 
	        Array.setBoolean(array, index++, ((Boolean)iv).booleanValue());
	      } else if (iv.getClass().isArray()) {
	        array = Array.newInstance(iv.getClass(), len); 
	        Array.set(array, index++, iv);
	      } else {
	        System.out.println("Array element type is unknown!");
                System.exit(-1);
	      }
	    }
	  }
	  (COMMA iv=initialValue[eltType]
	  {
	    if (iv instanceof Long) {
	      Array.setLong(array, index++, ((Long)iv).longValue());
	    } else if (iv instanceof Integer) {
	      Array.setInt(array, index++, ((Integer)iv).intValue());
	    } else if (iv instanceof Float) {
	      Array.setFloat(array, index++, ((Float)iv).floatValue());
	    } else if (iv instanceof Double) {
	      Array.setDouble(array, index++, ((Double)iv).doubleValue());
	    } else if (iv instanceof Boolean) {
	      Array.setBoolean(array, index++, ((Boolean)iv).booleanValue());
	    } else if (iv.getClass().isArray()) {
	      Array.set(array, index++, iv);
	    }  
	  }
	  )* RBRACE
	  {
	    o = array;
	  }
	  )
	{
	    //System.out.println("initialValue: " + o.toString());
	};		

function [BlockGraph blockGraph]
	{
	  Loop firstLoop = null;
	  BlockNode firstBlock = null;
	  BlockNode blockNode = null;
          Loop lp = null;
          Loop parentLoop = null;
	}:
	FUNCTION id:DECLVARID 
	{
          parentLoop = new Loop(id.getText(), Loop.ROOT);
          blockGraph.setRootLoop(parentLoop);
	}
        eol! ((blockNode=block[parentLoop] 
	{
	  if (firstBlock == null) {
	    firstBlock = blockNode;
	    blockGraph.setFirstBlock(blockNode);
	    if (firstLoop == null) {
	      parentLoop.setLoopEntry(blockNode);
	      //System.out.println("Loop entry block is: " + blockNode.getName());
	    }
	  }
	  blockGraph.addNode(blockNode);
	  parentLoop.addLoopNode(blockNode);
	  //System.out.println("Added block node to loop tree: " + blockNode.getName());
	}
	)| (lp=loop[parentLoop, blockGraph]
	{
	  if ((firstBlock == null) && (firstLoop == null)) {
	    firstLoop = lp;
	    parentLoop.setLoopEntry(lp);
	    //System.out.println("Loop entry loop is: " + lp.getName());
	  }
	  parentLoop.addLoopNode(lp);
	  //System.out.println("Added loop to loop tree: " + lp.getName());
	}
	))* FUNCTION END DECLVARID eol! 
	{
	  try {
	    PhiInfo.patch();
	  } catch (IllegalOperand e) {
	    System.err.println("Error patching phi instruction.");
	    throw(e);
	  }
	  if (parentLoop != null) {
	    //System.out.println("Loop tree: " + parentLoop.toString());
	  }
	};

block [Loop parentLoop] returns [BlockNode blockNode]
	{
	  blockNode = null;
	  Instruction inst = null;
	  Varid v = null;
	  LinkedList iList = null;
	}:
	BLOCK v=varid
	{
	  blockNode = new BlockNode();
	  if (v.isVersioned()) {
	    blockNode.setName(v.getBasename(), v.getVersion());
	  } else {
	    blockNode.setName(v.getBasename());
	  }
	  //System.out.println("Processing block node: " + v.getBasename());
	  blockNode.setLoopParent(parentLoop);
	}
	eol! (iList=instruction 
	{
	  for(ListIterator iter = iList.listIterator(); iter.hasNext(); ) {
	    inst = (Instruction)iter.next();
	    if (inst != null) {
	      blockNode.addInstruction(inst);
	    }
	  }
	})* BLOCK END VARID eol! 
	{
	};

loop [Loop parent, BlockGraph blockGraph] returns [Loop lp]
	{
	  BlockNode blockNode = null;
	  LoopNode entryNode = null;
	  Loop childLoop = null;
	  Loop firstLoop = null;
	  lp = null;
	}:
	LOOP varid:VARID 
	{
	  lp = new Loop(varid.getText(), Loop.NORMAL);
	  //System.out.println("Processing loop: " + varid.getText());
	}
	eol! (blockNode=block[parent]
	{
	  blockGraph.addNode(blockNode);
	  if ((entryNode == null) && (firstLoop == null)) {
	    entryNode = blockNode;
	    lp.setLoopEntry(entryNode);
	    //System.out.println("Loop entry block is: " + blockNode.getName());
	  }
	  lp.addLoopNode(blockNode);
	  //System.out.println("Added block node to loop tree: " + blockNode.getName());
	}
	| childLoop=loop[lp, blockGraph]
	{
	  if ((entryNode == null) && (firstLoop == null)) {
	    firstLoop = childLoop;
	    lp.setLoopEntry(childLoop);
	    //System.out.println("Loop entry loop is: " + childLoop.getName());
	  }
	  lp.addLoopNode(childLoop);
	  //System.out.println("Added loop to loop tree: " + childLoop.getName());
	}
	)* LOOP END varid2:VARID eol!
	{
	  lp.setLoopParent(parent);
	};

instruction returns [ LinkedList iList]  
	{
	  iList = null;
	}:
	(iList=loadI 
	 | iList=storeI
	 | iList=terminatorI
	 | iList=binaryI
	 | iList=bitwiseBinaryI
	 | iList=shiftI
	 | iList=setccI
	 | iList = selectI
	 | iList = getelementptrI
	 | iList = phiI
	 | iList = callI
	 | iList = castI
	 | iList = switchI) eol! 
	{
	};

loadI returns [ LinkedList iList ] 
	{
	  iList = new LinkedList();
	  Type t = null;
	  Instruction inst = null;
	  Operand resOperand = null;
	  Operand srcOperand = null;
	  Varid resVarid, srcVarid = null;
	  String addrOpName = null;
	  GepInfo gepInfo = null;
	}:
	(resVarid=varid EQUAL LOAD t=type 
	{
	  if (!t.isPointer()) {
	    System.err.println("Error:  Pointer type required for load: " + t + " on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  try {
	    if (((PointerType)t).getType() == Type.Bool) {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBoolean(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBoolean(resVarid.getBasename());
	      }
	    } else {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBlock(resVarid.getBasename());
	      }
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	}
	(srcVarid=varid
	{
	  try {
	    // If it has been assigned as an addr operand as a result of a phi, 
	    // obtain it this way.  But what if the phi comes after?
	    srcOperand = Operand.getOperand(srcVarid.getBasename(), srcVarid.getVersion());

	    // otherwise make a primal for it
	    if (srcOperand == null) {
	      srcOperand = Operand.newPrimal(LT(0).getText());
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating primal operand: " + LT(0).getText() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  if (srcOperand.isAddr()) {
	    Operand primalOp = (Operand)GepInfo.addrOperandHashMap.get(srcOperand);
	    if (primalOp == null) {
	      System.err.println("Yipes, addrOperandHashMap doesn't have a primal");
	      System.exit(-1);
	    }
	    inst = ALoad.create(Operators.ALOAD, t, resOperand, srcOperand, primalOp);
	  } else {  
	    inst = Load.create(Operators.LOAD, t, resOperand, srcOperand);
	  }
	  iList.addLast(inst);
	}
	| GETELEMENTPTR LPAREN gepInfo=getelementptrInfo RPAREN 
	{
    	  // make unique variable for source operand
	  addrOpName = GepInfo.names.getUniqueName("%load_addr");
	  try {
	    srcOperand = Operand.newAddr(addrOpName);
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating addr operand: " + addrOpName + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Getelementptr.create(Operators.GETELEMENTPTR, srcOperand, gepInfo.type, gepInfo.operand, gepInfo.pairs);
	  iList.addLast(inst);
	  inst = ALoad.create(Operators.ALOAD, t, resOperand, srcOperand, gepInfo.operand);
	  iList.addLast(inst);
	}
	))
	{
	};

storeI returns [ LinkedList iList ] 
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t, t1, t2 = null;
	  Operand srcOperand, dstOperand = null;
	  GepInfo gepInfo = null;
	  String addrOpName = null;
	  Varid dstVarid = null;
	}:
	(STORE t=type srcOperand=value[t, false] COMMA t2=type
        {
	  if (!t2.isPointer()) {
	    System.err.println("Error:  Pointer type required for store: " + t2 + " on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  t1 = ((PointerType)t2).getType();
	} 
	(dstVarid=varid 
	{
	  if (t!= t1) {
	    System.err.println("Error:  In store instruction, type of source operand must be the same as the pointer type of the destination on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  try {
	    // If it has been assigned as an addr operand as a result of a phi, 
	    // obtain it this way.  But what if the phi comes after?
	    dstOperand = Operand.getOperand(dstVarid.getBasename(), dstVarid.getVersion());

	    // otherwise make a primal for it
	    if (dstOperand == null) {
	      dstOperand = Operand.newPrimal(LT(0).getText());
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating primal operand: " + LT(0).getText() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  if (dstOperand.isAddr()) {
	    Operand primalOp = (Operand)GepInfo.addrOperandHashMap.get(dstOperand);
	    if (primalOp == null) {
	      System.err.println("Yipes, addrOperandHashMap doesn't have a primal");
	      System.exit(-1);
	    }
	    inst = AStore.create(Operators.ASTORE, t1, dstOperand, primalOp, srcOperand);
	  } else {  
	    inst = Store.create(Operators.STORE, t1, dstOperand, srcOperand);
	  }
	  iList.addLast(inst);
	}
	| GETELEMENTPTR LPAREN gepInfo=getelementptrInfo RPAREN
	{
	// make unique variable for destination operand
	  addrOpName = GepInfo.names.getUniqueName("%store_addr");
	  try {
	    dstOperand = Operand.newAddr(addrOpName);
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating addr operand: " + addrOpName + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Getelementptr.create(Operators.GETELEMENTPTR, dstOperand, gepInfo.type, 
	    gepInfo.operand, gepInfo.pairs);
	  iList.addLast(inst);
	  inst = AStore.create(Operators.ASTORE, t1, dstOperand, gepInfo.operand, srcOperand);
	  iList.addLast(inst);
	}
	 ))
	{
	};

terminatorI returns [ LinkedList iList ] 
	{
	  iList = null;
	}:
	(iList=branchI | iList=retI) 
	{
	};

branchI returns [ LinkedList iList ]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Operand condOperand, iftrueOperand, iffalseOperand, dstOperand = null;
	}:
	(BR BOOL condOperand=value[Type.Bool, false] COMMA LABEL iftrueOperand=value[Type.Label, false] COMMA LABEL iffalseOperand=value[Type.Label, false]
	{
	  inst = Branch.create(Operators.BR, (BooleanOperand)condOperand, (LabelOperand)iftrueOperand, (LabelOperand)iffalseOperand); 
	  iList.addLast(inst);
	})
	| (BR LABEL dstOperand=value[Type.Label, false]
	{
	  inst = Goto.create(Operators.GOTO, (LabelOperand)dstOperand);
	  iList.addLast(inst);
	})
	{
	};


retI returns [ LinkedList iList ]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t = null;
	  Operand o = null;
	}:
	((RET t=type o=value[t, false]
	{
	  if (!(t.isFirstClass())) {
	    System.err.println("Error:  Type for return instruction must be first class on line: " + LT(0).getLine());
            System.exit(-1);
	  }
	  inst = Return.create(Operators.RET, t, o);	
	})
	| (RET VOID
	{
  	  inst = Return.create(Operators.RET);	
	}))
	{
	  iList.addLast(inst);
	};

binaryI returns [ LinkedList iList ] 
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t = null;
	  Operand resOperand, val1Operand, val2Operand = null;
	  Operator op = null;
	  Varid resVarid = null;
	}:
	resVarid=varid EQUAL op=binaryOp t=type val1Operand=value[t, false] COMMA val2Operand=value[t, false]
	{
	  if (!(t.isInteger() || t.isFloat() || t.isDouble())) {
	    System.err.println("Error:  Type for binary operation must be integer, float or double on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  try {
	    if (resVarid.isVersioned()) {
	      resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	    } else {
	      resOperand = Operand.newBlock(resVarid.getBasename());
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating block operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Binary.create(op, t, resOperand, val1Operand, val2Operand);
	  iList.addLast(inst);
	}; 

bitwiseBinaryI returns [ LinkedList iList ] 
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t = null;
	  Operand resOperand, val1Operand, val2Operand = null;
	  Operator op = null;
	  Varid resVarid = null;
	}:
	resVarid=varid EQUAL op=bitwiseBinaryOp t=type val1Operand=value[t, false] COMMA val2Operand=value[t, false]
	{
	  if (!(t.isIntegral())) {
	    System.err.println("Error:  Type for bitwise binary operation must be integral on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  try {
	    if (t == Type.Bool) {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBoolean(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBoolean(resVarid.getBasename());
	      }
	    } else {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBlock(resVarid.getBasename());
	      }
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Binary.create(op, t, resOperand, val1Operand, val2Operand);
	  iList.addLast(inst);
	}; 

shiftI returns [ LinkedList iList ] 
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t = null;
	  Operand resOperand, val1Operand, val2Operand = null;
	  Operator op = null;
	  Varid resVarid = null;
	}:
	// Second value type should really be a ubyte, but we don't handle those yet.
	resVarid=varid EQUAL op=shiftOp t=type val1Operand=value[t, false] COMMA UBYTE val2Operand=value[t, false]
	{
	  if (!t.isInteger()){
	    System.err.println("Error:  First type argument to shift instruction must be integer on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  try {
	    if (resVarid.isVersioned()) {
	      resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	    } else {
	      resOperand = Operand.newBlock(resVarid.getBasename());
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating block operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Binary.create(op, t, resOperand, val1Operand, val2Operand);
	  iList.addLast(inst);
	}; 

binaryOp returns [ Operator op ]
	{
	  op = null;
	}:
	(ADD 
	{op = Operators.ADD;}
	| SUB
	{op = Operators.SUB;}
	| MUL
	{op = Operators.MUL;}
	| DIV
	{op = Operators.DIV;} 
	| REM
	{op = Operators.REM;} );

bitwiseBinaryOp returns [ Operator op ]
	{
	  op = null;
	}:
	( AND
	{op = Operators.AND;}
	| OR
	{op = Operators.OR;}
	| XOR
	{op = Operators.XOR;} );

shiftOp returns [Operator op]
	{
	  op = null;
	}:
	( SHL
	{op = Operators.SHL;}
	| SHR
	{op = Operators.SHR; });

setccI returns [LinkedList iList ]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t = null;
	  Operand resOperand, val1Operand, val2Operand = null;
	  Operator op = null;
	}:
	resOperand=value[Type.Bool, false] EQUAL op=setccOp t=type val1Operand=value[t, false] COMMA val2Operand=value[t, false]
	{
	  if (!t.isFirstClass()){
	    System.err.println("Error:  Type argument to setcc instruction must be first class on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  inst = Test.create(op, t, (BooleanOperand)resOperand, val1Operand, val2Operand);
	  iList.addLast(inst);
	};

setccOp returns [ Operator op ]
	{
	  op = null;
	}:
	(SETGT
	{op = Operators.SETGT;}
	| SETGE
	{op = Operators.SETGE;}
	| SETLT
	{op = Operators.SETLT;}
	| SETLE
	{op = Operators.SETLE;}
	| SETNE
	{op = Operators.SETNE;}
	| SETEQ
	{op = Operators.SETEQ;});

phiI returns [LinkedList iList]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t = null;
	  LinkedList values = new LinkedList();
	  Operand resOperand, val, lab = null;
	  Varid resVarid = null;
	  int index = 0;
	  LinkedList phiInfoList = new LinkedList();
	  GepInfo gepInfo = null;
	  Operand srcOperand = null;
    String addrOpName = null;
	}:
	resVarid=varid EQUAL PHI t=type (LBRACKET 
  (val=value[t, true]
  {
	  if (val.isUnknown()) {
	    phiInfoList.add(new PhiInfo(index, ((UnknownOperand)val).getOrigName(), val.getName(), val.getAssignment()));
	  }
	  values.addLast(val);
  }
  | GETELEMENTPTR LPAREN gepInfo=getelementptrInfo RPAREN
  {
    addrOpName = GepInfo.names.getUniqueName("%phi_addr");
    try {
      srcOperand = Operand.newAddr(addrOpName);
System.out.println("creating phi address: " + addrOpName);
    } catch (IllegalOperand e) {
      System.err.println("Error creating addr operand: " + addrOpName + " on line: " + LT(0).getLine());
      throw(e);
    }
    inst = Getelementptr.create(Operators.GETELEMENTPTR, srcOperand, gepInfo.type, gepInfo.operand, gepInfo.pairs);
    iList.addLast(inst);
    values.addLast(srcOperand);
  }
  ) COMMA lab=value[Type.Label, false] RBRACKET
	{
	  values.addLast(lab);
	  if (!t.isFirstClass()){
	    System.err.println("Error:  Type argument to phi instruction must be first class on line: " + LT(0).getLine());
            System.exit(-1);
	  }
	  index++;
	}
	) (COMMA LBRACKET 
  (val=value[t, true]
  {
	  if (val.isUnknown()) {
	    phiInfoList.add(new PhiInfo(index, ((UnknownOperand)val).getOrigName(), val.getName(), val.getAssignment()));
	  }
	  values.addLast(val);
  }
  | GETELEMENTPTR LPAREN gepInfo=getelementptrInfo RPAREN
  {
    addrOpName = GepInfo.names.getUniqueName("%phi_addr");
System.out.println("creating phi address: " + addrOpName);
    try {
      srcOperand = Operand.newAddr(addrOpName);
    } catch (IllegalOperand e) {
      System.err.println("Error creating addr operand: " + addrOpName + " on line: " + LT(0).getLine());
      throw(e);
    }
    inst = Getelementptr.create(Operators.GETELEMENTPTR, srcOperand, gepInfo.type, gepInfo.operand, gepInfo.pairs);
    iList.addLast(inst);
    values.addLast(srcOperand);
  }
  ) COMMA lab=value[Type.Label, false] RBRACKET
	{
	  values.addLast(lab);
	  index++;
	}
	)*
  {
	  try {
	    if (t.isPointer()) {
	      resOperand = Operand.newPrimal(resVarid.getBasename() + "." + resVarid.getVersion());
	    } else if (t == Type.Bool) {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBoolean(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBoolean(resVarid.getBasename());
	      }
	    } else {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBlock(resVarid.getBasename());
	      }
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Phi.create(Operators.PHI, t, resOperand, values);
	  iList.addLast(inst);
	  PhiInfo.patchList.addLast(inst);
	  PhiInfo.patchList.addLast(phiInfoList);
	};

callI returns [LinkedList iList]
	{
	  iList =  new LinkedList();
	  Instruction inst = null;
	  Varid resVarid = null;
	  Type retType = null;
	  Varid funcVarid = null;
	  int numArgs = 0;
	  LinkedList args = new LinkedList();
	  Type argType = null;
	  Operand argOperand = null;
	  Operand resOperand = null;
	  LabelOperand funcOperand = null;
	}:
	resVarid=varid EQUAL (TAIL)? CALL retType=type funcVarid=varid LPAREN 
	(RPAREN 
	| ((argType=type argOperand=value[argType, false] 
	{ 
	  numArgs++;
	  args.addLast(new TypeOperand(argType)); 
	  args.addLast(argOperand); 
	}
	) (COMMA argType=type argOperand=value[argType, false]
	{
	  numArgs++;
	  args.addLast(new TypeOperand(argType)); 
	  args.addLast(argOperand); 
	})* RPAREN)
	)
	{
	  try {
	    if (resVarid.isVersioned()) {
	        resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	    } else {
	      resOperand = Operand.newBlock(resVarid.getBasename());
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }

	  try {
	    if (funcVarid.isVersioned()) {
	      funcOperand = Operand.newLabel(funcVarid.getBasename(), funcVarid.getVersion());
	    } else {
	      funcOperand = Operand.newLabel(funcVarid.getBasename());
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating function operand: " + funcVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }

	  inst = Call.create(Operators.CALL, retType, resOperand, funcOperand, args);
	  iList.addLast(inst);
	  
	};

castI returns [LinkedList iList]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type fromType, toType = null;
	  Operand resOperand, val = null;
	  Varid resVarid = null;
	}:
	resVarid=varid EQUAL CAST fromType=type val=value[fromType, false] TO toType=type
        {
	  if (!fromType.isFirstClass()){
	    System.err.println("Error:  From type argument to cast instruction must be first class on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  if (!toType.isFirstClass()){
	    System.err.println("Error:  To type argument to cast instruction must be first class on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  try {
	    if (toType == Type.Bool) {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBoolean(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBoolean(resVarid.getBasename());
	      }
	    } else {
	      if (resVarid.isVersioned()) {
	        resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	      } else {
	        resOperand = Operand.newBlock(resVarid.getBasename());
	      }
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Cast.create(Operators.CAST, resOperand, fromType, val, toType);
	  iList.addLast(inst);
	};

selectI returns [LinkedList iList]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Type t1, t2 = null;
	  Operand resOperand, cond, op1, op2 = null;
	  Varid resVarid = null;
	}:
	resVarid=varid EQUAL SELECT BOOL cond=value[Type.Bool, false] COMMA t1=type op1=value[t1, false] COMMA t2=type op2=value[t2, false] 
        {
	  if (t1 != t2) {
	    System.err.println("Error:  Both type arguments to select instruction must be the same, on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  if (!t1.isFirstClass()){
	    System.err.println("Error:  Type arguments to select instruction must be first class on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  
	  try {
	    if (t1 == Type.Bool) {
	      if (resVarid.isVersioned()) {
		resOperand = Operand.newBoolean(resVarid.getBasename(), resVarid.getVersion());
	      } else {
		resOperand = Operand.newBoolean(resVarid.getBasename());
	      }
	    } else {
	      if (resVarid.isVersioned()) {
		resOperand = Operand.newBlock(resVarid.getBasename(), resVarid.getVersion());
	      } else {
		resOperand = Operand.newBlock(resVarid.getBasename());
	      }
	    }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Select.create(Operators.SELECT, t1, resOperand, (BooleanOperand)cond, op1, op2);
	  iList.addLast(inst);
	};

getelementptrI returns [LinkedList iList]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Varid resVarid = null;
	  Operand resOperand = null;
	  GepInfo gepInfo = null;
	}:
	resVarid=varid EQUAL GETELEMENTPTR gepInfo=getelementptrInfo
	{
	  try {
	      if (resVarid.isVersioned()) {
		resOperand = Operand.newAddr(resVarid.getBasename(), resVarid.getVersion());
	      } else {
		resOperand = Operand.newAddr(resVarid.getBasename());
	      }
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating result operand: " + resVarid.getBasename() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	  inst = Getelementptr.create(Operators.GETELEMENTPTR, resOperand, gepInfo.type, gepInfo.operand, gepInfo.pairs);
	  GepInfo.addrOperandHashMap.put(resOperand, gepInfo.operand);
	  iList.addLast(inst);
	};
	
getelementptrInfo returns [GepInfo info]
	{
	  Type t = null;
	  Type t1 = null;
	  LinkedList pairs = new LinkedList();
	  Operand val = null;
	  info = null; 
	}:
	// if we handled user-defined structs, then you'd have to add that here
	t=type ptrVarid:VARID (COMMA t1=type val=value[t1, false]
	{
	  pairs.addLast(new TypeOperand(t1));
	  pairs.addLast(val);
	}
	)*
	{
	  try {
	    //System.out.println("Making a primal from: " + ptrVarid.getText());
	    info = new GepInfo(t, pairs, Operand.newPrimal(ptrVarid.getText()));
	  } catch (IllegalOperand e) {
	    System.err.println("Error creating primal operand: " + ptrVarid.getText() + " on line: " + LT(0).getLine());
	    throw(e);
	  }
	};

switchI returns [LinkedList iList]
	{
	  iList = new LinkedList();
	  Instruction inst = null;
	  Operand val, dest, val2, dest2 = null;
	  Type t, t2 = null;
	  LinkedList cases = new LinkedList();
	}:
	SWITCH t=type 
	{
	  if (!t.isInteger()){
	    System.err.println("Error:  First type argument to switch instruction must be integer on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	}
	val=value[t, false] COMMA LABEL dest=value[Type.Label, false] LBRACKET eol! (t2=type val2=value[t, false] COMMA LABEL dest2=value[Type.Label, false] 
	{
	  if (!t2.isInteger()){
	    System.err.println("Error:  Type argument to switch case must be integer on line: " + LT(0).getLine());
	    System.exit(-1);
	  }
	  cases.addLast(val2);
	  cases.addLast(dest2);
	}
	eol!)* RBRACKET
	{
	  inst = Switch.create(Operators.SWITCH, t, val, (LabelOperand)dest, cases);
	  iList.addLast(inst);
	};

type returns [ Type t ]
	{ 
	  Token tok = null;
	  t = null;
	  Type t2 = null;
	}: 
	((VOID {t = Type.Void;}
	  | BOOL {t = Type.Bool;}
	  | SBYTE {t = Type.Sbyte;} 
	  | UBYTE { t = Type.Ubyte;}
	  | SHORT { t = Type.Short;}
	  | USHORT { t = Type.Ushort; }
	  | INT { t = Type.Int;} 
	  | UINT { t = Type.Uint;}
	  | LONG { t = Type.Long;}
	  | ULONG { t = Type.Ulong;}
	  | FLOAT { t = Type.Float;}
	  | DOUBLE { t = Type.Double;}
	  | LABEL { t = Type.Label;}
	  | (LBRACKET num:PINTEGER dv:DECLVARID t2=type RBRACKET
	  { 
	    if (dv.getText().compareTo("x") != 0) {
	      System.err.println("Error: array dimensions must be separated by x on line: " + LT(0).getLine());
	      System.exit(-1);
	    }
	    t = new ArrayType(t2, Integer.parseInt(num.getText()));
	  })
	  // would put case for user-defined structure type here if we handled it
	  ) (STAR {t = new PointerType(t);})*)
	 {
	   //tok = LT(0); 
	   //System.out.println("type="+tok.getText());
	 };

varid returns [Varid v]
	{
	  Token tok = null;
	  String s = null;
	  String numString = "";
	  String zeroString = "";
	  String nameString = "";
	  int index, version = 0;
	  boolean isVersioned = false;
	  v = null;
	}:
	(VARID
	  {
	    tok = LT(0);
	    s = tok.getText(); 
	    //System.out.print("varid: " + s);

	    // Find out where last '.' is.
	    index = s.lastIndexOf('.');
	    //System.out.print(" index: " + index);

	    // If there is a last '.', add one to the index, so we can get to the numbers
	    // after it, if there are any.
	    if (index != -1) index++;

            // Get ahold of the numbers after the '.', if there are any.
	    // For example, tmp.134  would have numString 134, that is the version.
	    if ((index <= (s.length()-1)) && (index > -1)) {
	      numString = s.substring(index);
	      //System.out.print(" num: " + numString);
	      for (int i = 0; i < numString.length(); i++) {
		if (!Character.isDigit(numString.charAt(i))) {
		  break;
		}
		isVersioned = true;
	      }
	    }

            // In the case of tmp.345, 345 is the version.
	    // tmp.foo is not versioned.
	    if (isVersioned) {
	      //System.out.println(" versioned");

              // Check for leading zeros in the numString,
	      // for example, tmp.001
	      for (int i=0; i < numString.length(); i++) {
		if (numString.charAt(i) == '0') {
		  zeroString = zeroString + '0';
	          //System.out.print(" zeroString: " + zeroString);
		} else {
		  break;
		}

		// Special case: if the numString is all zeros
		if (zeroString.length() == numString.length()) {

		  // If numString is only one 0, then don't make a zeroString.
		  // The 0 is the version and there is no confusion.
		  if (numString.length() == 1) {
		    zeroString = "";
		  } else {
		    // Otherwise, take one 0 off the zeroString,
		    // because we want to use that 0 for its version number.
		    // The other zeros are for its unique name we're making.
		    zeroString = zeroString.substring(1, zeroString.length());
		  }
		}
	      }
	      
	      // Create the version number from the numString
	      version = Integer.parseInt(numString);

	      // If the version number is preceded by 0's, we have a problem,
	      // because if we just make tmp.001 have name tmp and version 1,
	      // that would collide with tmp.1, which also has name tmp and version
	      // 1.  So, what we need to do is to make the new unique
	      // name the name base, followed by "__", and then followed by
	      // the zero string.  For example, tmp.001 would become tmp__00 and have
	      // version 1.  Similarly, tmp.000 would become tmp__00 and have version 0.
	      if ((zeroString.compareTo("")) != 0) {
		nameString = s.substring(0, index-1) + "__" + s.substring(index, index + zeroString.length());
	        //System.out.print(" nameString w/ 0s: " + nameString);
	      } else {

		// In the case of no zerostring (no preceding zeros in the
		// number part of the string), just use the base name and use the
		// number part for the version (tmp.345 has name tmp and number 345).

		nameString = s.substring(0, index-1);
	        //System.out.print(" nameString w/o 0s: " + nameString);
	      }

	      v = new Varid(nameString , version);
	    } else {

	      // In the case of no version number, it is probably a primal
	      v = new Varid(s);
	      //System.out.println(" NOT versioned");
	    }
	    //System.out.println();
 	  }
	  )
	  {
	  };

value [Type t, boolean must_exist] returns [ Operand o ]
	/* must_exist means that value() can't return null.  If anything, it would 
	return UnknownOperand.  This is used mostly for phi instructions.  */
	{ 
	  Token tok = null;
	  o = null;
	  String s = null;
	  Varid v = null;
	}:  
	(v=varid
	  { 
	    try {
	      if (v.isVersioned()) {
	          o = Operand.getOperand(v.getBasename(), v.getVersion());
	        } else {
	          o = Operand.getOperand(v.getBasename(), Operand.NOT_ASSIGNED);
	        }
	      if ((o == null) && !must_exist) {
	        if (t == Type.Label) { 
	          if (v.isVersioned()) {
	            o = Operand.newLabel(v.getBasename(), v.getVersion());
	          } else {
	            o = Operand.newLabel(v.getBasename());
	          }
	        } else if (t == Type.Bool) {
	          if (v.isVersioned()) {
	            o = Operand.newBoolean(v.getBasename(), v.getVersion());
	          } else {
	            o = Operand.newBoolean(v.getBasename());
	          }
	        } else {
	          if (v.isVersioned()) {
	            o = Operand.newBlock(v.getBasename(), v.getVersion());
	          } else {
	            o = Operand.newBlock(v.getBasename());
	          }
		}
	      } else if (o == null) {
	          if (v.isVersioned()) {
	            o = Operand.newUnknown(LT(0).getText(), v.getBasename(), v.getVersion());
	          } else {
	            o = Operand.newUnknown(v.getBasename());
	          }
	      }
	    } catch (IllegalOperand e) {
	      tok = LT(0);
	      System.err.println("Error creating operand: " + tok.getText() + " on line: " + tok.getLine());
	      throw(e);
	    }
	     
	    //System.out.println("value Operand " + o.toString());
	  }
	  /* There is a problem with integer constants coming in as decimal strings
	     because they can be unsigned and Java doesn't handle reading in
	     unsigned decimal strings.  It assumes they are signed, so the number
	     could go past the bounds of a signed int (or long if that is the case)
	     and I haven't handled this yet.
	     */
	  | NINTEGER  
	  { 
	    tok = LT(0); 
	    if ((t == Type.Long) || (t == Type.Ulong)) {
	      o = Operand.newLongConstant(Long.parseLong(tok.getText())); 
	    } else if ((t == Type.Int) || (t == Type.Uint) || (t == Type.Ubyte)
	    || (t == Type.Sbyte) || (t == Type.Ushort) || (t == Type.Short)) {
	      o = Operand.newIntConstant(Integer.parseInt(tok.getText())); 
	    }
	  }
	  | PINTEGER  
	  { 
	    tok = LT(0); 
	    if ((t == Type.Long) || (t == Type.Ulong)) {
	      o = Operand.newLongConstant(Long.parseLong(tok.getText())); 
	    } else if ((t == Type.Int) || (t == Type.Ubyte)
	    || (t == Type.Sbyte) || (t == Type.Ushort) || (t == Type.Short)) {
	      o = Operand.newIntConstant(Integer.parseInt(tok.getText())); 
	    } else if (t == Type.Uint) {
	      BigInteger uInt = new BigInteger(tok.getText());
	      if(uInt.compareTo(new BigInteger("2147483647")) == 1) {
	        BigInteger uIntMinusOne = uInt.subtract(new BigInteger("1"));
		BigInteger inverseInt = uIntMinusOne.not();
		Integer convertedInt = new Integer(-inverseInt.intValue());
		o = Operand.newIntConstant(convertedInt.intValue());
	      }
	      else
	        o = Operand.newIntConstant(Integer.parseInt(tok.getText())); 
					    }
	  }
	  | FPCONSTANT 
	  { 
	    tok = LT(0);
	    if (t == Type.Float) {
	      o = Operand.newFloatConstant(Float.parseFloat(tok.getText())); 
	    } else  if (t == Type.Double) {
	      o = Operand.newDoubleConstant(Double.parseDouble(tok.getText())); 
	    } else {
	      System.err.println("Type not correct for floating point constant\n");
	      System.exit(-1);
	    }
	  } 
	  | HEX_INTCONSTANT 
	  { 
	    tok = LT(0);
	    s = tok.getText(); 
	    boolean signed = false;
	    if (s.charAt(0) == 's') {
	      signed = true;
	      if ((t == Type.Ulong) || (t == Type.Uint)) {
		System.err.println("Error:  Unsigned type does not match signed literal");
		System.exit(-1);
	      }
	    }  else {
	      if ((t == Type.Long) || (t == Type.Int)) {
		System.err.println("Error:  Signed type does not match unsigned literal");
		System.exit(-1);
	      }
	    }
	    s = s.substring(3, s.length());
	    if ((t == Type.Long) || (t == Type.Ulong)) {
	      o = Operand.newLongConstant(Long.parseLong(s)); 
	    } else if ((t == Type.Int) || (t == Type.Uint)) {
	      o = Operand.newIntConstant(Integer.parseInt(s)); 
	    }
	  } 
	  | TRUE
	  {
	    try {
	      tok = LT(0);
	      o = Operand.newBoolean(tok.getText());
	    } catch (IllegalOperand e) {
	      System.err.println("Error creating boolean operand: " + tok.getText() + " on line: " + tok.getLine());
	      throw(e);
	    }
	  }
	  | FALSE
	  {
	    try {
	      tok = LT(0);
	      o = Operand.newBoolean(tok.getText());
	    } catch (IllegalOperand e) {
	      System.err.println("Error creating boolean operand: " + tok.getText() + " on line: " + tok.getLine());
	      throw(e);
	    }
	  }
	  | HEX_FPCONSTANT 
	  { 
	    tok = LT(0); 
	    s = tok.getText();
	    s = s.substring(2, s.length());
	    //System.err.println("FPConstant: " + s);
	    if (s.length() <= Convert.ieeeFloatHexStringLength) {
	      if (t == Type.Float) {
		float f = Convert.ieeeFloatHexStringToFloat(s);
		o = Operand.newFloatConstant(f); 
	      } else if (t == Type.Double) {
		double d = Convert.ieeeDoubleHexStringToDouble(s);
		o = Operand.newDoubleConstant(d); 
	      } else {
		System.err.println("Type not correct for constant\n");
		System.exit(-1);
	      }
	    } else if (s.length() <= Convert.ieeeDoubleHexStringLength) {
		if (t == Type.Double) {
		  double d = Convert.ieeeDoubleHexStringToDouble(s);
		  o = Operand.newDoubleConstant(d); 
		} else if (t == Type.Float) {
		  float f = Convert.ieeeDoubleHexStringToFloat(s);
		  o = Operand.newFloatConstant(f); 
		} else System.err.println("Type not correct for constant\n");
	    } else System.err.println("Type not correct for constant\n");
         }
	  ) 
	 {
	  if (o == null) {
	    tok = LT(0);
	    System.err.println("Error:  Null operand for variable: " + tok.getText() + " on line: " + tok.getLine());
	    System.exit(-1);
	  }
	   //s = tok.getText(); 
	   //System.out.println("value="+s);
	 };

eol! :
	(options { warnWhenFollowAmbig = false; } :
	EOL!
	)+;

